Task Reminder Tracking System
Overview
Implement a continuous monitoring system that tracks upcoming task reminders and task start times, showing a modal popup using the existing OptionsModal when they trigger while the app is open.

Architecture
1. Domain Model
Create domain/model/UpcomingReminder.kt:

Simplified data class: taskId: Int, triggerTime: LocalDateTime, reminder: TaskReminderEntry? (null if it's a task start time)
Unique identifier: combination of taskId + triggerTime for tracking triggered reminders
2. Reminder Calculation Service
Create domain/service/ReminderCalculator.kt:

Function: calculateReminderTriggerTime(task: Task, reminder: TaskReminderEntry): LocalDateTime
For START reminders: task.date - offset (convert ReminderOffsetUnit to Duration)
For END reminders: task.endDate - offset (if endDate exists)
Handle all offset units: MINUTES, HOURS, DAYS, WEEKS, MONTHS
Function: getUpcomingRemindersForTask(task: Task): List<UpcomingReminder>
If task has reminders: calculate trigger time for each reminder
Always include task start time as reminder (if task is not all-day)
Return empty list for all-day tasks (no start time reminder)
Function: getUpcomingRemindersForRecurringTask(baseTask: Task): List<UpcomingReminder>
Get first occurrence using RecurrenceCalculator.generateOccurrences() with future window
For first occurrence: calculate reminders and start time (if not all-day)
Return list of reminders for that occurrence
3. Repository Extension
Extend TaskRepository interface and TaskRepositoryImpl:

Add method: fun getUpcomingReminders(limit: Int = 5): Flow<List<UpcomingReminder>>
Heavy operation - must handle properly:
Query all non-deleted tasks (both single and recurring base tasks)
For each single task: get reminders + start time (if not all-day)
For each recurring base task: get first occurrence, then get reminders + start time for that occurrence
Flatten all reminders into single list
Sort by triggerTime ascending
Take first limit items
Return Flow that emits this sorted list
Use flowOn(Dispatchers.Default) for heavy computation
Consider caching or debouncing to avoid excessive recalculations
4. Reminder Tracking ViewModel
Create ui/screens/reminder/ReminderTrackingViewModel.kt:

Inject TaskRepository
Observe getUpcomingReminders(limit = 5) Flow
Track triggered reminders: Set<String> where key is "${taskId}_${triggerTime.toEpochMilli()}"
StateFlow: triggeredReminder: StateFlow<UpcomingReminder?> (for showing popup)
StateFlow: triggeredTask: StateFlow<Task?> (full task object for modal)
Function: checkAndTriggerReminders() - polls once per second
Compare current time with trigger times of tracked reminders
When trigger time passes and not yet triggered, emit to triggeredReminder
Load full task object and emit to triggeredTask
Function: dismissReminder() - marks reminder as handled, triggers recalculation
Add to triggered set
Clear triggeredReminder and triggeredTask
Repository will automatically recalculate (Flow will emit new list with 5th item)
Use viewModelScope.launch with while(true) { delay(1000) } for 1-second polling
5. Reminder Modal Integration
Reuse existing OptionsModal with TaskPreviewComponent:

In ui/MainScreen.kt or global composable
Show OptionsModal when triggeredReminder is not null
Content: TaskPreviewComponent(task = triggeredTask)
Title: "Reminder" or "Task Starting" based on whether reminder exists
Buttons:
First button: "Go to Task" - navigate to TaskScreen with task date
Second button: "Dismiss" - call dismissReminder()
6. Integration
Update ui/MainScreen.kt:

Inject ReminderTrackingViewModel using hiltViewModel()
Observe triggeredReminder and triggeredTask StateFlows
Show OptionsModal when reminder triggers
Start polling when app is in foreground (use LifecycleObserver or DisposableEffect)
7. Continuous Monitoring
In ReminderTrackingViewModel:

Launch coroutine in init or when ViewModel is created
Poll every 1 second: while(true) { checkAndTriggerReminders(); delay(1000) }
Only check reminders that haven't been triggered yet
When reminder triggers, pause polling until dismissed (or continue for next reminder)
Implementation Details
Reminder Trigger Time Calculation
// For START reminder: task.date - offset
// For END reminder: task.endDate - offset
// Convert ReminderOffsetUnit to Duration:
// MINUTES -> Duration.ofMinutes(offsetValue)
// HOURS -> Duration.ofHours(offsetValue)
// DAYS -> Duration.ofDays(offsetValue)
// WEEKS -> Duration.ofDays(offsetValue * 7)
// MONTHS -> use ChronoUnit.MONTHS (approximate)
Handling Recurring Tasks
Query all base recurring tasks (rrule IS NOT NULL)
For each, generate first occurrence using RecurrenceCalculator.generateOccurrences() with window from now to future
Calculate reminders and start time for that first occurrence only
This avoids generating all occurrences (performance optimization)
State Management
Track triggered reminders using Set of unique keys: "${taskId}_${triggerTime.toEpochMilli()}"
When reminder is dismissed, add to triggered set
Repository Flow will automatically emit new list (now includes 5th item since 4 are still tracked)
ViewModel filters out triggered reminders when checking
Files to Create
domain/model/UpcomingReminder.kt
domain/service/ReminderCalculator.kt
ui/screens/reminder/ReminderTrackingViewModel.kt
Files to Modify
data/repository/TaskRepository.kt - Add getUpcomingReminders() method
data/repository/TaskRepositoryImpl.kt - Implement getUpcomingReminders() with heavy computation on background thread
ui/MainScreen.kt - Integrate ReminderTrackingViewModel and show OptionsModal with TaskPreviewComponent
Testing Considerations
Test reminder calculation with various offset units (minutes, hours, days, weeks, months)
Test tasks with no reminders (should still track start time if not all-day)
Test all-day tasks (should not track start time)
Test recurring tasks with reminders (first occurrence only)
Test reminder triggering timing accuracy (1-second polling)
Test recalculation after dismissal (5th item becomes available)
Test performance with many tasks (ensure heavy computation is on background thread)